#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile

# If you want transient local:
# from rclpy.qos import QoSProfile, QoSDurabilityPolicy

import struct

from sensor_msgs.msg import PointCloud2, PointField


def generate_points(t, N: int = 1000):
    """
    Generate N points at a certain 'x' based on time t.
    y and z are kept constant for demo purposes.
    """
    # Define a 3D rectangle and shift if over time
    # LOOK AT NUMPY MESHGRID
    MAX_X = 5
    return [(max(0.5, (1 - t) * MAX_X), ((i / N) * 0.1), (i / N) * 0.5) for i in range(N)]


class ContinuousPointCloudPublisher(Node):
    def __init__(
        self,
        frame_id: str = "map",
        timestep: float = 0.01,
        topic_name: str = "/my_pointcloud",
    ):
        """
        Node that continuously publishes a PointCloud2 at a fixed rate.

        :param frame_id:  The frame in which the cloud is published (default: "map").
        :param timestep:   The period (in seconds) between publishes. (default: 0.1 s => 10 Hz)
        :param topic_name: The topic name to publish to (default: "/my_pointcloud").
        """
        super().__init__("continuous_pointcloud_publisher")
        self.frame_id = frame_id
        self.timestep = timestep
        self.t = 0.0

        # Optional QoS settings:
        qos_profile = QoSProfile(depth=10)
        # If you need transient local so that late joiners can get the last message:
        # qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL

        # Create the publisher
        self.publisher = self.create_publisher(PointCloud2, topic_name, qos_profile)

        # Create a timer that calls `timer_callback` every `timestep` seconds
        self.timer = self.create_timer(self.timestep * 10.0, self.timer_callback)

    def timer_callback(self):
        """
        This function is called every 'timestep' seconds to publish a new point cloud.
        """
        stamp = self.get_clock().now().to_msg()
        cloud_msg = self._create_pointcloud2(timestamp=stamp, frame_id=self.frame_id)

        self.publisher.publish(cloud_msg)
        self.get_logger().info(f"Published PointCloud2 with {cloud_msg.width} points (t = {self.t:.2f}).")

        # Increment time for the next publish
        self.t += self.timestep

    def _create_pointcloud2(self, timestamp, frame_id):
        """
        Helper method to create a PointCloud2 message with points generated by `generate_points()`.
        """
        points = generate_points(self.t, N=10000)
        for p in points:
            print(p[1])

        cloud_msg = PointCloud2()
        cloud_msg.header.stamp = timestamp
        cloud_msg.header.frame_id = frame_id

        cloud_msg.height = 1  # For an unordered point cloud
        cloud_msg.width = len(points)

        # Define the fields for x, y, z (4 bytes each, float32)
        cloud_msg.fields = [
            PointField(name="x", offset=0, datatype=PointField.FLOAT32, count=1),
            PointField(name="y", offset=4, datatype=PointField.FLOAT32, count=1),
            PointField(name="z", offset=8, datatype=PointField.FLOAT32, count=1),
        ]
        cloud_msg.is_bigendian = False
        cloud_msg.point_step = 12  # 3 floats * 4 bytes each
        cloud_msg.row_step = cloud_msg.point_step * cloud_msg.width
        cloud_msg.is_dense = True

        # Pack the point data into a byte array
        data_buffer = []
        for x, y, z in points:
            data_buffer.append(struct.pack("<fff", x, y, z))  # little-endian float32
        cloud_msg.data = b"".join(data_buffer)

        return cloud_msg


def main(args=None):
    rclpy.init(args=args)

    node = ContinuousPointCloudPublisher(
        frame_id="base_link",
        topic_name="/robot_interface/front_camera/depth/color/points",
        timestep=0.01,  # 100 Hz
    )

    try:
        # This will process timer callbacks and keep the node alive
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()
